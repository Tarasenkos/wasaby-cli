const fs = require('fs-extra');
const xml2js = require('xml2js');
const shell = require('shelljs');
const CONFIG = 'config.json';
const path = require('path');
const reposStore = '_repos';
const repModulesMap = new Map();
const builderConfigName = 'builderConfig.json';
const pMap = require('p-map');

function walkDir(dir, callback, rootDir) {
   rootDir = rootDir || dir;
   fs.readdirSync(dir).forEach(f => {
      let dirPath = path.join(dir, f);
      let relativePath = path.relative(rootDir, dir);
      let isDirectory = fs.statSync(dirPath).isDirectory();
      isDirectory ? walkDir(dirPath, callback, rootDir) : callback(path.join(relativePath, f));
   });
};

const reportNotExistsTemplate = {
   testsuite:{
      $: {
         name:"Mocha Tests",
         tests:"1",
         failures:"1",
         errors:"1"
      },
      testcase: [{
         $: {
            classname:"All tests",
            name:"Critical error report does not exists",
            time:"0"
         },
         failure: {
            img: {
               $: {
                  src: 'data:image/png;base64,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uocEQ0QoAAAfmncOHszzP92ZF1/elbf37Z/u4Zy0zpwzO4suWJhLfvsiAcpxR4QCAABQxppQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyojqi88SAAAD70lEQVRQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyohQAAAAyvx/5xnXIyjnKo4AAAAASUVORK5CYII='
               }
            }
         }
      }]
   }
};

/**
 * Модуль для запуска юнит тестов
 * @class Cli
 * @author Ганшин Я.О.
 */
class Cli {
   constructor() {
      let config = this.readConfig();
      this._repos = config.repositories;
      this._store = config.store;
      this._workDir = config.workDir;
      this._testReports = new Map();
      this._argvOptions = this._getArgvOptions();
      this._testBranch = this._argvOptions.branch || this._argvOptions.rc || '';
      this._testRep = this._argvOptions.rep;
      this._unitModules = [];
      this._childProcessMap = [];
      this._rc = this._argvOptions.rc;
      this._modulesMap = new Map();
      this._dependTest = {};
      this._testList = undefined;
      if (!this._testRep) {
         throw new Error('Параметр --rep не передан');
      }
   }

   /**
    * Запускает сборку юнит тестов
    * @return {Promise<void>}
    */
   async run() {
      try {
         await this.initStore();
         await this.initWorkDir();
         await this.startTest();
         this.checkReport();
         this.prepareReport();
         this.log('Закончили тестирование');
      } catch(e) {
         await this._closeChildProcess();
         this.prepareReport();
         this.log(`Тестирование завершено с ошибкой ${e}`);
         throw e;
      }
   }

   /**
    * Возвращает список репозиториев для тестирования
    * @return {Array}
    * @private
    */
   _getTestList() {
      if (this._testList) {
         return this._testList;
      }

      let tests = [];
      if (this._testRep !== 'all') {
         tests = [this._testRep];
         let cfg = this._repos[this._testRep];
         let modules = this._getModulesWithDepend(this._getModulesFromMap(this._testRep));
         modules.forEach((name) => {
            let cfg = this._modulesMap.get(name);
            if (!tests.includes(cfg.rep)) {
               tests.push(cfg.rep);
            }
         });
      } else {
         tests = Object.keys(this._repos).filter((name) => {
            return !!this._repos[name].test;
         });
      }
      return this._testList = tests;
   }

   _getModulesFromMap(repName) {
      let moduels = [];
      this._modulesMap.forEach(cfg => {
         if (cfg.rep == repName) {
            moduels.push(cfg.name);
         }
      });
      return moduels;
   }

   _getModulesWithDepend(modules) {
      let result = modules.slice();
      this._modulesMap.forEach(cfg => {
         if (!result.includes(cfg.name) && cfg.depends.some(dependName => result.includes(dependName))) {
            result.push(cfg.name);
         }
      });
      if (modules.length  !== result.length) {
         return this._getModulesWithDepend(result);
      }
      return result;
   }
   /**
    * Записывает объект в xml файл
    * @param {string} filePath - Путь до файла
    * @param {Object} obj - Объект который надо записать
    * @private
    */
   _writeXmlFile(filePath, obj) {
      let builder = new xml2js.Builder();
      let xml = builder.buildObject(obj);
      fs.outputFileSync(filePath, xml);
   }

   /**
    * Дописывает в отчеты название репозитория
    */
   prepareReport() {
      this.log('Подготовка отчетов');
      this._testReports.forEach((filePath, name) => {
         if (fs.existsSync(filePath)) {
            const parser = new xml2js.Parser();
            let xml_string = fs.readFileSync(filePath, "utf8");
            parser.parseString(xml_string, (error, result) => {
               if (error === null) {
                  result.testsuite.testcase.forEach((item) => {
                     item.$.classname = `[${name}]: ${item.$.classname}`;
                  });
                  this._writeXmlFile(filePath, result);
               }
               else {
                  this.log(error);
               }
            });
         }
      });
   }

   /**
    * Проверяет наличие отчетов по юнит тестам, если какого-то отчета нет кидает ошибку
    */
   checkReport() {
      this.log('Проверка существования отчетов');
      let error = [];
      this._testReports.forEach((path, name) => {
         if (!fs.existsSync(path)) {
            error.push(name);
            this._writeXmlFile(path, reportNotExistsTemplate)
         }
      });
      if (error.length > 0) {
         this.log(`Сгенерированы отчеты с ошибками: ${error.join(', ')}`);
      }
      this.log('Проверка пройдена успешно');
   }

   /**
    * Закрвыает все дочерние процессы
    * @return {Promise<void>}
    * @private
    */
   async _closeChildProcess() {
      await Promise.all(this._childProcessMap.map((process) => {
         return new Promise((resolve) => {
            process.on('close', () => {
               resolve();
            });
            process.withErrorKill = true;
            process.kill('SIGKILL');
         });
      }));
      this._childProcessMap = [];
   }

   /**
    * Возвращает конфиг
    * @return {any}
    */
   readConfig() {
      let data = fs.readFileSync(CONFIG);
      return JSON.parse(data);
   }

   /**
    * Возвращает опции командной строки
    * @private
    */
   _getArgvOptions() {
      let options = {};
      process.argv.slice(2).forEach(arg => {
         if (arg.startsWith('--')) {
            let argName = arg.substr(2);
            const [name, value] = argName.split('=', 2);
            options[name] = value === undefined ? true : value;
         }
      });
      return options;
   }

   /**
    * возвращает набор интерфейсных модулей из репозитория
    * @param {String} name - название репозитория в конфиге
    * @return {Array}
    * @private
    */
   async _getModulesByRepName(name) {
      const cfg = this._repos[name];
      let allModules = this._findModulesInRepDir(name);
      let uiModules = await this._addToModulesMap(allModules);
      repModulesMap.set(name, uiModules);

      return uiModules.concat(cfg.modules || []);
   }

   /**
    * Ищет модули в репозитории по s3mod
    * @param {String} name - название репозитория в конфиге
    * @return {Array}
    * @private
    */
   _findModulesInRepDir(name) {
      let s3mods = [];
      walkDir(path.join(this._store, reposStore, name), (filePath) => {
         if (filePath.includes('.s3mod')) {
            let splitFilePath = filePath.split(path.sep);
            splitFilePath.splice(-1, 1);
            let modulePath = path.join.apply(path, splitFilePath);
            let moduleName = splitFilePath[splitFilePath.length - 1];
            s3mods.push({
               name: moduleName,
               rep: name,
               path: filePath,
               modulePath: modulePath
            });
         }
      });
      return s3mods;
   }

   _readXmlFile(filePath) {
      return new Promise((resolve, reject) => {
         const parser = new xml2js.Parser();
         let xml_string = fs.readFileSync(filePath, "utf8");
         parser.parseString(xml_string, (error, result) => {
            if (error === null) {
               resolve(result);
            }
            else {
               this.log(error);
               reject(error);
            }
         });
      });
   }

   async _addToModulesMap(modules) {
      let addedModules = [];
      await pMap(modules, (cfg) => {
         return this._readXmlFile(path.join(this._store, reposStore, cfg.rep, cfg.path)).then((xmlObj) => {
            if (!this._modulesMap.has(cfg.name) && xmlObj.ui_module) {
               cfg.depends = [];
               if (xmlObj.ui_module.depends && xmlObj.ui_module.depends[0]) {
                  let depends = xmlObj.ui_module.depends[0];
                  if (depends.ui_module) {
                     depends.ui_module.forEach(function (item) {
                        cfg.depends.push(item.$.name);
                     })
                  }
                  if (depends.module) {
                     depends.module.forEach(function (item) {
                        cfg.depends.push(item.$.name);
                     })
                  }
               }
               addedModules.push(cfg.modulePath);
               this._modulesMap.set(cfg.name, cfg);
            }
         })
      }, {
         concurrency: 4
      });
      return addedModules;
   }

   /**
    * Создает конфиг для билдера
    * @return {Promise<void>}
    * @private
    */
   _makeBuilderConfig() {
      let builderConfig = require('./builderConfig.base.json');
      let testList = this._getTestList().slice();
      testList.forEach((name) => {
         builderConfig.modules.push({
            name: name + '_test',
            path: ['.', this._store, name, name + '_test'].join('/')
         });

         let modules = this._getModulesFromMap(name);
         modules = modules.concat(this._repos[name].modules || []);

         modules.forEach((modulePath) => {
            const moduleName = this._getModuleNameByPath(modulePath);
            if (moduleName !== 'unit') {
               const isNameInConfig = builderConfig.modules.find((item) => (item.name == moduleName));
               if (!isNameInConfig) {
                  builderConfig.modules.push({
                     name: moduleName,
                     path: ['.', this._store, name, 'module', moduleName].join('/')
                  })
               }
            }
         });

      });

      return fs.outputFile(`./${builderConfigName}`, JSON.stringify(builderConfig, null, 4));
   }

   /**
    * возвращает название модуля по пути
    * @param {String} path
    * @return {String}
    * @private
    */
   _getModuleNameByPath(path) {
      return path.includes('/') ? path.split('/').pop() : path.split('\\').pop();
   }

   _getTestConfig(name, suffix) {
      const testConfig = require('./testConfig.base.json');
      let cfg = Object.assign({}, testConfig);
      let fullName = name + (suffix||'');
      cfg.tests = name + '_test';

      cfg.htmlCoverageReport = cfg.htmlCoverageReport.replace('${module}', fullName);
      cfg.jsonCoverageReport = cfg.jsonCoverageReport.replace('${module}', fullName);
      cfg.report = cfg.report.replace('${module}', fullName );
      this._testReports.set(fullName, cfg.report);
      return cfg;
   }
   /**
    * Создает конфиги для юнит тестов
    * @param {String} name - название репозитория в конфиге
    * @return {Promise<[any, ...]>}
    * @private
    */
   _makeTestConfig(name) {
      let defaultPort = 10025;
      let configPorts = this._argvOptions.ports ? this._argvOptions.ports.split(',') : [];
      return Promise.all(this._getTestList().map((name, i) => {
         return new Promise(resolve => {
            let cfg = this._getTestConfig(name, '_node');
            fs.outputFileSync(`./testConfig_${name}.json`, JSON.stringify(cfg, null, 4));
            if (this._repos[name].unitInBrowser) {
               let cfg = this._getTestConfig(name, '_browser');
               cfg.url.port = configPorts.shift() || defaultPort++;
               fs.outputFileSync(`./testConfig_${name}InBrowser.json`, JSON.stringify(cfg, null, 4));
            }
            resolve();
         });
      }));
   }

   /**
    * инициализирует рабочую директорию: запускает билдер, копирует тесты
    * @return {Promise<void>}
    */
   async initWorkDir() {
      this.log(`Подготовка тестов`);
      let pathToCfg = path.join(process.cwd(), 'builderConfig.json');
      try {
         await this._makeBuilderConfig();
         await this._execute(
            `node node_modules/gulp/bin/gulp.js --gulpfile=node_modules/sbis3-builder/gulpfile.js build --config=${pathToCfg}`,
            __dirname,
            true,
            'builder'
         );
         this._copyUnit();
         await this._linkFolder();
         this.log(`Подготовка тестов завершена успешно`);
      } catch(e) {
         throw e;
         throw new Error(`Подготовка тестов завершена с ошибкой ${e}`);
      }
   }

   /**
    * копирует tslib
    * @private
    */
   _tslibInstall() {
      return this._execute(
         `node node_modules/saby-typescript/install.js --tslib=application/WS.Core/ext/tslib.js`,
         __dirname,
         true,
         'typescriptInstall'
      );
   }

   /**
    * запускает тесты в браузере
    * @param {String} name - название репозитория в конфиге
    * @return {Promise<void>}
    * @private
    */
   async _startBrowserTest(name) {
      let cfg = this._repos[name];
      if (cfg.unitInBrowser && name !== 'engine') {
         this.log(`Запуск тестов в браузере`, name);
         await this._execute(
            `node node_modules/saby-units/cli.js --browser --report --config="./testConfig_${name}InBrowser.json"`,
            __dirname,
            true,
            `test browser ${name}`
         );
         this.log(`тесты в браузере завершены`, name);
      }
   }

   /**
    * Запускает тестирование
    * @return {Promise<void>}
    */
   async startTest() {
      await this._makeTestConfig();
      await this._tslibInstall();
      await pMap(this._getTestList(), (name) => {
         this.log(`Запуск тестов`, name);
         return Promise.all([
            this._execute(
               `node node_modules/saby-units/cli.js --isolated --report --config="./testConfig_${name}.json"`,
               __dirname,
               true,
               `test node ${name}`
            ),
            this._startBrowserTest(name)
         ]);
      },{
         concurrency: 4
      });
   }

   /**
    * инициализация хранилища, клонирует необходимые рапозитории из гита, либо копирует из переданной папки
    * @return {Promise<void>}
    */
   async initStore() {
      this.log(`Инициализация хранилища`);
      try {
         await fs.remove(this._workDir);
         await fs.remove('builder-ui');
         await fs.remove(this._store);
         await fs.mkdirs(path.join(this._store, reposStore));
         await Promise.all(Object.keys(this._repos).map((name) => {
            if (!fs.existsSync(path.join(this._store, name))) {
               return this.initRepStore(name)
                  .then(
                     this.copy.bind(this, name)
                  );
            }
         }));
         this.log(`Инициализация хранилища завершена успешно`);
      } catch (e) {
         throw new Error(`Инициализация хранилища завершена с ошибкой ${e}`);
      }
   }

   /**
    * Создает симлинки в рабочей директории, после прогона билдера
    * @return {Promise<void>}
    * @private
    */
   async _linkFolder() {
      for (const name in this._repos) {
         if (this._repos[name].linkFolders) {
            for (const pathOriginal in this._repos[name].linkFolders) {

               const pathDir = path.join(this._store, reposStore, name, pathOriginal);
               const pathLink =  path.join(this._workDir, this._repos[name].linkFolders[pathOriginal]);
               await fs.ensureSymlink(pathDir, pathLink);
            }
         }
      }
   }

   /**
    * создает симлинки для модулей
    * @param {String} name - название репозитория в конфиге
    * @return {Promise<[any, ...]>}
    */
   async copy(name) {
      let cfg = this._repos[name];
      let reposPath = path.join(this._store, reposStore, name);
      await fs.mkdirs(path.join(this._store, name));
      if (cfg.test) {
         await fs.ensureSymlink(path.join(reposPath, cfg.test), path.join(this._store, name, name + '_test'));
      }
      const modules = await this._getModulesByRepName(name);

      return Promise.all(modules.map((module => {
         this.log(`копирование модуля ${name}/${module}`, name);
         if (this._getModuleNameByPath(module) == 'unit') {
            this._unitModules.push(path.join(reposPath, module));
         } else {
            return fs.ensureSymlink(path.join(reposPath, module), path.join(this._store, name, 'module', this._getModuleNameByPath(module))).catch((e) => {
               throw new Error(`Ошибка при копировании репозитория ${name}: ${e}`);
            });
         }
      })));
   }

   /**
    * переключает репозиторий на нужную ветку
    * @param {String} name - название репозитория в конфиге
    * @param {String} checkoutBranch - ветка на которую нужно переключиться
    * @param {String} pathToRepos - путь до репозитория
    * @return {Promise<void>}
    */
   async checkout(name, checkoutBranch, pathToRepos) {
      if (!checkoutBranch) {
         throw new Error(`Не удалось определить ветку для репозитория ${name}`);
      }
      try {
         this.log(`Переключение на ветку ${checkoutBranch}`, name);
         await this._execute(`git checkout ${checkoutBranch}`, pathToRepos, `checkout ${name}`);
      } catch (err) {
         throw new Error(`Ошибка при переключение на ветку ${checkoutBranch} в репозитории ${name}: ${e}`);
      }
      if (name === this._testRep) {
         this.log(`Попытка смержить ветку "${checkoutBranch}" с "${this._rc}"`, name);
         try {
            await this._execute(`git merge origin/${this._rc}`, pathToRepos, `merge ${name}`);
         } catch (e) {
            throw new Error(`При мерже "${checkoutBranch}" в "${this._rc}" произошел конфликт`);
         }
      }
   }

   /**
    * Клонирует репозиторий из гита
    * @param {String} name - название репозитория в конфиге
    * @return {Promise<*|string>}
    */
   async cloneRepToStore(name) {
      try {
         this.log(`git clone ${this._repos[name].url}`, name);

         await this._execute(`git clone ${this._repos[name].url} ${name}`, path.join(this._store, reposStore), `clone ${name}`);

         return path.join(this._store, reposStore, name);
      } catch (err) {
         throw new Error(`Ошибка при клонировании репозитория ${name}: ${err}`);
      }
   }

   /**
    * Копирует репозиторий, если в параметрах запуска передали путь
    * @param {String} pathToOriginal
    * @param {String} name - название репозитория в конфиге
    * @return {Promise<void>}
    */
   async copyRepToStore(pathToOriginal, name) {
      try {
         this.log(`Копирование репозитория`, name);

         await fs.ensureSymlink(pathToOriginal, path.join(this._store, reposStore, name));
      } catch (err) {
         throw new Error(`Ошибка при копировании репозитория ${name}: ${err}`);
      }
   }

   /**
    * Инициализация хранилища, клонирует/копирует репозитории переключает на нужные ветки
    * @param {String} name - название репозитория в конфиге
    * @return {Promise<void>}
    */
   async initRepStore(name) {
      if (this._argvOptions[name]) {
         if (fs.existsSync(this._argvOptions[name])) {
            return this.copyRepToStore(this._argvOptions[name], name);
         } else {
            return this.checkout(
               name,
               this._argvOptions[name],
               await this.cloneRepToStore(name, this._argvOptions[name])
            );
         }
      } else {
         const branch = name === this._testRep ? this._testBranch : this._rc;
         return this.checkout(
            name,
            branch,
            await this.cloneRepToStore(name)
         );
      }
   }

   /**
    * Копирует юнит тесты
    * @private
    */
   _copyUnit() {
      this._unitModules.forEach((source) => {
         walkDir(source, (filePath) => {
            if (!filePath.includes('.test.')) {
               fs.copySync(path.join(source, filePath), path.join(this._workDir, 'unit', filePath));
            }
         });
      });
   }

   /**
    * Выводит сообщение в лог
    * @param {String} message
    */
   log(message, name) {
      let date = new Date();
      let time = `${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}:${date.getMilliseconds()}`;
      name = name ? ' '+name : '';
      console.log(`[${time}]${name}: ${message}`);
   }

   /**
    * Выполняет команду shell
    * @param {String} command - текст команды
    * @param {String} path - путь по которому надо выполнить команду
    * @param {Boolean} force - если true в случае ошибки вернет промис resolve
    * @param {String} processName - метка процесса в логах
    * @return {Promise<any>}
    * @private
    */
   _execute(command, path, force, processName) {
      if (typeof force == 'string') {
         processName = force;
         force = false;
      }
      return new Promise((resolve, reject) => {
         const cloneProcess = shell.exec(`cd ${path} && ${command}`, {
            silent: true,
            async: true
         });
         this._childProcessMap.push(cloneProcess);
         cloneProcess.stdout.on('data', (data) => {
            this.log(data, processName);
         });

         cloneProcess.stderr.on('data', (data) => {
            this.log(data, processName);
         });

         cloneProcess.on('exit', (code) => {
            this._childProcessMap.splice(this._childProcessMap.indexOf(cloneProcess), 1);
            if (force || !code && !cloneProcess.withErrorKill) {
               resolve();
            } else {
               reject();
            }
         });
      });
   };
}

module.exports = Cli;

if (require.main.filename === __filename) {
   //Если файл запущен напрямую запускаем тестирование
   let cli = new Cli();
   cli.run().catch((e) => {
      console.error(e);
      process.exit(2);
   })
}



